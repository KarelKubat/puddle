// Package puddle is a somewhat simplified worker pool for Go, but it should serve lots of use cases.
package puddle

import (
	"sync"
)

// Worker is the type of workers to attach to a puddle: they must accept Args, and return an
// anonymous interface type.
type Worker func(Args) any

// Args are the arguments to any Worker to attach: a list of anonymous interfaces.
type Args []any

// Pool is the shallow puddle.
type Pool struct {
	ch chan any
	wg sync.WaitGroup
}

// New returns a new Pool without size restrictions. Use New().WithSize(nr) to limit the asynchronous
// processing to a given maximum size of workers. Example:
//
//	 // Unlimited parallel workers.
//		pl := puddle.New()
func New() *Pool {
	wp := &Pool{
		ch: make(chan any),
	}
	return wp
}

// WithSize limits the puddle size to the indicate number of workers. Example:
//
//	// Limit the max # of inflight workers to 5
//	pl := puddle.New().WithSize(5)
func (wp *Pool) WithSize(size int) *Pool {
	if size > 0 {
		close(wp.ch)
		wp.ch = make(chan any, size)
	}
	return wp
}

// Work adds a worker to the puddle. The worker must (a) accept anything of type Args, which is a list
// of anonymous interfaces, and (b) it must return one anonymous any interface. Example:
//
//	  // Wrapper for Printf. Return as one type:
//	  type ret struct {
//			n   int
//			err error
//	  }
//	  // Wrapper function to return whatever fmt.Printf() returns and to return it as a ret type:
//	  func myPrintf(args puddle.Args) any {
//			if len(args) < 1 {
//				return ret{n: 0, err: errors.New("myPrintf: no fomat string")}
//			}
//			n, err := fmt.Printf(args[0].(string), args[1:]...)
//			return ret{n: n, err: err}
//		}
func (wp *Pool) Work(fn Worker, args Args) {
	wp.wg.Add(1)
	go func(args Args) {
		defer wp.wg.Done()
		wp.ch <- fn(args)
	}(args)
}

// Wait returns a channel of an "any" interface, which is also the return type of a Worker.
// The caller may consume the channel in a "for range" statement. The channel unblocks when
// all workers have finished.
//
// The type that the channel returns is an anonymous "any". The caller must ensure that this
// is converted to whatever a worker function (type "Worker") returns. Example:
//
//			 // Hypothetical return from "myFunc"
//			 type ret struct {
//				err error  // incase it went wrong
//			    timing time.Duraton  // how long it took
//			 }
//
//	      Hypothetical "myFunc" conforming to puddle.Worker.
//			 func myFunc(args puddle.Args) any {
//				// fill me in
//			 }
//
//			 p := puddle.New().WithSize(200)  // no more than 200 parallel workers
//			 for i := 0; i < 100000 {
//			    p.Work(myFunc, Args{i})
//			 }
//		  // Responses will be generated by at most 200 workers.
//			 for v := range p.Wait() {
//			      r := v.(ret)
//			      if r.err != nil {
//						fmt.Fprintln(os.Stderr, r.errE
//					}  else {
//						fmt.Println("processed in", r.timing)
//					}
//				 }
func (wp *Pool) Wait() chan any {
	go func() {
		wp.wg.Wait()
		close(wp.ch)
	}()
	return wp.ch
}
